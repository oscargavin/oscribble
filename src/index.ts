import { app, BrowserWindow, ipcMain, dialog, shell } from 'electron';
import { StorageService } from './services/storage';
import { ContextService } from './services/context';
import { ClaudeService } from './services/claude';
import { OpenAIService } from './services/openai';
import AutoContextService from './services/auto-context';
import { ProjectType } from './types';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Initialize services
let claudeService: ClaudeService | null = null;
let openaiService: OpenAIService | null = null;

// File watcher management
const fileWatchers = new Map<BrowserWindow, { watcher: fs.FSWatcher; timeout: NodeJS.Timeout | null; projectName: string }>();

/**
 * Start watching a project's notes.json file for external changes
 */
async function startWatchingProject(window: BrowserWindow, projectName: string) {
  // Stop any existing watcher for this window
  stopWatchingProject(window);

  // Get project to determine storage location
  const projects = await StorageService.getProjects();
  const project = projects.find(p => p.name === projectName);

  let notesPath: string;
  if (project && project.type === 'life_admin') {
    // Life admin: store in app data directory
    notesPath = path.join(os.homedir(), '.project-stickies', projectName, 'notes.json');
  } else {
    // Code project: store in app data directory (same location for now)
    notesPath = path.join(os.homedir(), '.project-stickies', projectName, 'notes.json');
  }

  try {
    const watcher = fs.watch(notesPath, (eventType) => {
      if (eventType === 'change') {
        // Get watcher data
        const watcherData = fileWatchers.get(window);
        if (!watcherData) return;

        // Debounce: Clear existing timeout
        if (watcherData.timeout) {
          clearTimeout(watcherData.timeout);
        }

        // Set new timeout (300ms debounce)
        watcherData.timeout = setTimeout(() => {
          // Send event to renderer
          window.webContents.send('notes-file-changed', projectName);
          watcherData.timeout = null;
        }, 300);
      }
    });

    fileWatchers.set(window, { watcher, timeout: null, projectName });
  } catch (error) {
    console.error(`Failed to watch notes.json for ${projectName}:`, error);
  }
}

/**
 * Stop watching files for a window
 */
function stopWatchingProject(window: BrowserWindow) {
  const watcherData = fileWatchers.get(window);
  if (watcherData) {
    watcherData.watcher.close();
    if (watcherData.timeout) {
      clearTimeout(watcherData.timeout);
    }
    fileWatchers.delete(window);
  }
}

/**
 * Create a new window, optionally for a specific project
 * @param projectName - Optional project to open in the window
 */
const createWindow = (projectName?: string): void => {
  // Create the browser window according to PRD specs
  const mainWindow = new BrowserWindow({
    width: 600,
    height: 800,
    minWidth: 400,
    minHeight: 500,
    frame: false, // Frameless window for sticky note look
    transparent: true, // Enable transparency for rounded corners
    hasShadow: true, // Drop shadow for sticky note effect
    backgroundColor: '#1a1a1a',
    resizable: true,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  // Build URL with optional project parameter
  let url = MAIN_WINDOW_WEBPACK_ENTRY;
  if (projectName) {
    // Pass project as query parameter
    url += `?project=${encodeURIComponent(projectName)}`;
    // Set window title to project name
    mainWindow.setTitle(`Oscribble - ${projectName}`);
  } else {
    mainWindow.setTitle('Oscribble');
  }

  // Load the app with optional project context
  mainWindow.loadURL(url);

  // Open the DevTools in development
  if (process.env.NODE_ENV === 'development') {
    mainWindow.webContents.openDevTools();
  }

  // Cleanup watcher when window closes
  mainWindow.on('closed', () => {
    stopWatchingProject(mainWindow);
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => createWindow());

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

// IPC Handlers - Register these BEFORE app ready to ensure they're available immediately

// Initialize Claude service
ipcMain.handle('init-claude', async (_, apiKey: string) => {
  try {
    claudeService = new ClaudeService(apiKey);
    // Initialize AutoContextService with the same API key
    AutoContextService.initClaude(apiKey);
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Initialize OpenAI service
ipcMain.handle('init-openai', async (_, apiKey: string) => {
  try {
    openaiService = new OpenAIService(apiKey);
    return { success: true };
  } catch (error) {
    console.error('Failed to initialize OpenAI:', error);
    return { success: false, error: error.message };
  }
});

// Transcribe audio with OpenAI
ipcMain.handle('transcribe-audio', async (_, audioBuffer: ArrayBuffer) => {
  try {
    if (!openaiService) {
      return { success: false, error: 'OpenAI not initialized' };
    }

    // Convert ArrayBuffer to Blob
    const audioBlob = new Blob([audioBuffer], { type: 'audio/webm' });
    const transcript = await openaiService.transcribe(audioBlob);

    return { success: true, data: transcript };
  } catch (error) {
    console.error('Transcription error:', error);
    return { success: false, error: error.message };
  }
});

// Get app settings
ipcMain.handle('get-settings', async () => {
  try {
    return await StorageService.getSettings();
  } catch (error) {
    return null;
  }
});

// Save app settings
ipcMain.handle('save-settings', async (_, settings) => {
  try {
    await StorageService.saveSettings(settings);
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Get all projects
ipcMain.handle('get-projects', async () => {
  try {
    return await StorageService.getProjects();
  } catch (error) {
    return [];
  }
});

// Add new project
ipcMain.handle('add-project', async (_, project) => {
  try {
    await StorageService.addProject(project);
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Update existing project
ipcMain.handle('update-project', async (_, project) => {
  try {
    await StorageService.updateProject(project);
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Delete project
ipcMain.handle('delete-project', async (_, projectName: string) => {
  try {
    await StorageService.deleteProject(projectName);
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Get notes for project
ipcMain.handle('get-notes', async (_, projectName: string) => {
  try {
    return await StorageService.getNotes(projectName);
  } catch (error) {
    return null;
  }
});

// Save notes
ipcMain.handle('save-notes', async (_, projectName: string, notes) => {
  try {
    await StorageService.saveNotes(projectName, notes);
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Save raw text (autosave)
ipcMain.handle('save-raw', async (_, projectName: string, text: string) => {
  try {
    await StorageService.saveRawText(projectName, text);
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Get raw text
ipcMain.handle('get-raw', async (_, projectName: string) => {
  try {
    return await StorageService.getRawText(projectName);
  } catch (error) {
    return null;
  }
});

// Gather context from mentions
ipcMain.handle('gather-context', async (_, rawText: string, projectRoot: string) => {
  try {
    const context = await ContextService.gatherContext(rawText, projectRoot);
    const formatted = ContextService.formatContextForPrompt(context);
    return { success: true, context: formatted };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Gather project context (unified @mentions + auto-discovery)
ipcMain.handle('gather-project-context', async (_, rawText: string, projectRoot: string) => {
  try {
    // Load preferred model from settings
    let preferredModel: any;
    try {
      const settings = await StorageService.getSettings();
      if (settings) {
        preferredModel = settings.preferred_model;
      }
    } catch (error) {
      console.warn('Failed to load preferred model from settings:', error);
    }

    const context = await ContextService.gatherProjectContext(rawText, projectRoot, preferredModel);
    return { success: true, data: context };
  } catch (error: any) {
    console.error('Error gathering project context:', error);
    return { success: false, error: error.message };
  }
});

// Format with Claude
ipcMain.handle('format-with-claude', async (_, rawText: string, contextStr: string, isVoiceInput = false, projectName?: string, projectType?: string) => {
  try {
    if (!claudeService) {
      throw new Error('Claude service not initialized');
    }

    // Get project to determine type if not provided
    let finalProjectType: ProjectType = (projectType as ProjectType) || 'code';
    if (projectName) {
      try {
        const projects = await StorageService.getProjects();
        const project = projects.find(p => p.name === projectName);
        if (project && project.type) {
          finalProjectType = project.type;
        }
      } catch (error) {
        console.warn('Failed to load project type, defaulting to code:', error);
      }
    }

    // Get recent completions for few-shot learning if project specified
    let recentCompletions;
    let existingTasks;
    if (projectName) {
      try {
        recentCompletions = await StorageService.getRecentCompletions(projectName, 10);
      } catch (error) {
        console.warn('Failed to load recent completions for few-shot learning:', error);
      }

      // Load existing tasks for dependency context
      try {
        const notes = await StorageService.getNotes(projectName);
        if (notes && notes.tasks) {
          existingTasks = notes.tasks;
        }
      } catch (error) {
        console.warn('Failed to load existing tasks for dependency context:', error);
      }
    }

    // Load user context, preferred model, and location from settings
    let userContext: string | undefined;
    let preferredModel: any;
    let userLocation: { city?: string; region?: string; country?: string; } | undefined;
    try {
      const settings = await StorageService.getSettings();
      if (settings) {
        // Load user context for life admin projects
        if (finalProjectType === 'life_admin' && settings.user_context) {
          userContext = settings.user_context;
        }
        // Load user location for life admin projects (for web search)
        if (finalProjectType === 'life_admin' && settings.user_location) {
          userLocation = settings.user_location;
        }
        // Load preferred model (applies to all projects)
        preferredModel = settings.preferred_model;
      }
    } catch (error) {
      console.warn('Failed to load settings:', error);
    }

    const response = await claudeService.formatTasks(rawText, contextStr, isVoiceInput, finalProjectType, recentCompletions, existingTasks, userContext, preferredModel, userLocation);
    return { success: true, data: response };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Format a single task with Claude
ipcMain.handle('format-single-task', async (_, taskText: string, projectRoot: string, useAutocontext: boolean = true) => {
  try {
    if (!claudeService) {
      throw new Error('Claude service not initialized');
    }

    let contextString = '';
    let contextFiles: { path: string; wasGrepped?: boolean; matchedKeywords?: string[]; }[] = [];

    // Only gather context if useAutocontext is true
    if (useAutocontext) {
      // Load preferred model from settings (for context discovery)
      let contextModel: any;
      try {
        const settings = await StorageService.getSettings();
        if (settings) {
          contextModel = settings.preferred_model;
        }
      } catch (error) {
        console.warn('Failed to load preferred model for context discovery:', error);
      }

      // Gather context using unified system (@mentions + auto-discovery)
      const contextResult = await ContextService.gatherProjectContext(taskText, projectRoot, contextModel);

      // Format context for Claude prompt
      if (contextResult.files && contextResult.files.length > 0) {
        contextString = contextResult.files.map(f => {
          const header = f.wasGrepped
            ? `--- ${f.path} (grep: ${f.matchedKeywords?.join(', ')}) ---`
            : `--- ${f.path} ---`;
          return `${header}\n${f.content}`;
        }).join('\n\n');
      }

      // Extract file metadata for storage with tasks
      contextFiles = contextResult.files.map(f => ({
        path: f.path,
        wasGrepped: f.wasGrepped,
        matchedKeywords: f.matchedKeywords
      }));

      console.log(`Context for single task: ${contextResult.files.length} files, ${contextResult.totalLines} lines (${contextResult.cacheHits} cached)`);
    }

    // Load preferred model from settings
    let preferredModel: any;
    try {
      const settings = await StorageService.getSettings();
      if (settings) {
        preferredModel = settings.preferred_model;
      }
    } catch (error) {
      console.warn('Failed to load preferred model from settings:', error);
    }

    // Format the task with Claude
    const response = await claudeService.formatTasks(taskText, contextString, false, 'code', undefined, undefined, undefined, preferredModel);

    return { success: true, data: response, contextFiles };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Get project files for autocomplete
ipcMain.handle('get-project-files', async (_, projectRoot: string) => {
  try {
    const { promises: fs } = require('fs');
    const path = require('path');

    const files: string[] = [];
    const maxFiles = 500; // Limit for performance

    async function scanDirectory(dir: string, relativePath: string = '') {
      if (files.length >= maxFiles) return;

      try {
        const entries = await fs.readdir(dir, { withFileTypes: true });

        for (const entry of entries) {
          if (files.length >= maxFiles) break;

          // Skip common ignore patterns
          if (
            entry.name.startsWith('.') ||
            entry.name === 'node_modules' ||
            entry.name === 'dist' ||
            entry.name === 'build' ||
            entry.name === '.webpack'
          ) {
            continue;
          }

          const fullPath = path.join(dir, entry.name);
          const relPath = relativePath ? `${relativePath}/${entry.name}` : entry.name;

          if (entry.isDirectory()) {
            await scanDirectory(fullPath, relPath);
          } else if (entry.isFile()) {
            files.push(relPath);
          }
        }
      } catch (error) {
        // Skip directories we can't read
      }
    }

    await scanDirectory(projectRoot);
    return { success: true, files };
  } catch (error) {
    return { success: false, error: error.message, files: [] };
  }
});

// Get directory suggestions for path autocomplete
ipcMain.handle('get-directory-suggestions', async (_, partialPath: string) => {
  try {
    const { promises: fs } = require('fs');
    const path = require('path');
    const os = require('os');

    let searchPath = partialPath || os.homedir();
    let searchDir = '';
    let prefix = '';

    // Expand ~ to home directory
    if (searchPath.startsWith('~')) {
      searchPath = searchPath.replace('~', os.homedir());
    }

    // Determine which directory to search and what prefix to match
    try {
      const stats = await fs.stat(searchPath);
      if (stats.isDirectory()) {
        // If it's a valid directory and ends with /, show its contents
        if (searchPath.endsWith('/') || searchPath.endsWith(path.sep)) {
          searchDir = searchPath;
          prefix = '';
        } else {
          // Valid directory but no trailing slash - show siblings
          searchDir = path.dirname(searchPath);
          prefix = path.basename(searchPath).toLowerCase();
        }
      }
    } catch {
      // Path doesn't exist yet, search parent directory
      searchDir = path.dirname(searchPath);
      prefix = path.basename(searchPath).toLowerCase();
    }

    // Read directory
    const entries = await fs.readdir(searchDir, { withFileTypes: true });
    const directories: string[] = [];

    for (const entry of entries) {
      if (entry.isDirectory()) {
        const name = entry.name;
        // Skip hidden directories
        if (name.startsWith('.')) {
          continue;
        }

        // Filter by prefix if provided
        if (prefix && !name.toLowerCase().startsWith(prefix)) {
          continue;
        }

        const fullPath = path.join(searchDir, name);
        directories.push(fullPath);

        if (directories.length >= 5) break; // Limit to 5
      }
    }

    return { success: true, directories };
  } catch (error) {
    console.error('Directory suggestions error:', error);
    return { success: false, error: error.message, directories: [] };
  }
});

// Select directory using native OS dialog
ipcMain.handle('select-directory', async (event, defaultPath?: string) => {
  try {
    const window = BrowserWindow.fromWebContents(event.sender);
    if (!window) {
      return { success: false, error: 'Window not found' };
    }

    // Expand ~ to home directory if provided
    let startPath = defaultPath;
    if (startPath && startPath.startsWith('~')) {
      startPath = startPath.replace('~', os.homedir());
    }

    const result = await dialog.showOpenDialog(window, {
      properties: ['openDirectory', 'createDirectory'],
      title: 'Select Project Root Directory',
      defaultPath: startPath || os.homedir(),
      buttonLabel: 'Select',
    });

    if (result.canceled || result.filePaths.length === 0) {
      return { success: false, canceled: true };
    }

    // Return the selected directory path
    return { success: true, path: result.filePaths[0] };
  } catch (error) {
    console.error('Directory selection error:', error);
    return { success: false, error: error.message };
  }
});

// Open a new window for a specific project
ipcMain.handle('open-project-window', async (_, projectName: string) => {
  try {
    // Verify project exists
    const projects = await StorageService.getProjects();
    const project = projects.find(p => p.name === projectName);

    if (!project) {
      return { success: false, error: 'Project not found' };
    }

    // Create new window with project context
    createWindow(projectName);

    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Close the current window
ipcMain.handle('close-window', async (event) => {
  const window = BrowserWindow.fromWebContents(event.sender);
  if (window) {
    window.close();
  }
  return { success: true };
});

// Start watching a project's notes.json file
ipcMain.handle('start-watching-project', async (event, projectName: string) => {
  const window = BrowserWindow.fromWebContents(event.sender);
  if (window) {
    await startWatchingProject(window, projectName);
  }
  return { success: true };
});

// Stop watching the current project
ipcMain.handle('stop-watching-project', async (event) => {
  const window = BrowserWindow.fromWebContents(event.sender);
  if (window) {
    stopWatchingProject(window);
  }
  return { success: true };
});

// Start task timer
ipcMain.handle('start-task-timer', async (_, projectName: string, taskId: string) => {
  try {
    const notes = await StorageService.getNotes(projectName);
    if (!notes) {
      return { success: false, error: 'Project not found' };
    }

    // Find the task recursively
    function findTask(tasks: any[]): any {
      for (const task of tasks) {
        if (task.id === taskId) {
          return task;
        }
        if (task.children && task.children.length > 0) {
          const found = findTask(task.children);
          if (found) return found;
        }
      }
      return null;
    }

    const task = findTask(notes.tasks);
    if (!task) {
      return { success: false, error: 'Task not found' };
    }

    // Set start time
    if (!task.metadata) {
      task.metadata = {};
    }
    task.metadata.start_time = Date.now();

    // Save updated notes
    await StorageService.saveNotes(projectName, notes);

    return { success: true, start_time: task.metadata.start_time };
  } catch (error) {
    console.error('Start task timer error:', error);
    return { success: false, error: error.message };
  }
});

// Complete task and log duration
ipcMain.handle('complete-task', async (_, projectName: string, taskId: string) => {
  try {
    const notes = await StorageService.getNotes(projectName);
    if (!notes) {
      return { success: false, error: 'Project not found' };
    }

    // Find the task recursively
    function findTask(tasks: any[]): any {
      for (const task of tasks) {
        if (task.id === taskId) {
          return task;
        }
        if (task.children && task.children.length > 0) {
          const found = findTask(task.children);
          if (found) return found;
        }
      }
      return null;
    }

    const task = findTask(notes.tasks);
    if (!task) {
      return { success: false, error: 'Task not found' };
    }

    // Calculate duration if task was started
    let duration = 0;
    if (task.metadata?.start_time) {
      duration = Date.now() - task.metadata.start_time;
      task.metadata.duration = duration;
    }

    // Save completion to log
    await StorageService.appendCompletion(projectName, {
      task_id: taskId,
      text: task.text,
      estimated_time: task.metadata?.effort_estimate,
      actual_time: duration,
      completed_at: Date.now()
    });

    // Save updated notes
    await StorageService.saveNotes(projectName, notes);

    return { success: true, duration };
  } catch (error) {
    console.error('Complete task error:', error);
    return { success: false, error: error.message };
  }
});

// Get recent completions for few-shot learning
ipcMain.handle('get-recent-completions', async (_, projectName: string, limit: number = 10) => {
  try {
    const completions = await StorageService.getRecentCompletions(projectName, limit);
    return { success: true, data: completions };
  } catch (error) {
    console.error('Get recent completions error:', error);
    return { success: false, error: error.message };
  }
});

// Log priority edit for learning feedback
ipcMain.handle('log-priority-edit', async (_, entry: any, projectName: string) => {
  try {
    await StorageService.appendPriorityEdit(projectName, entry);
    return { success: true };
  } catch (error) {
    console.error('Log priority edit error:', error);
    return { success: false, error: error.message };
  }
});

// Get recent priority edits for analysis
ipcMain.handle('get-recent-priority-edits', async (_, projectName: string, limit: number = 20) => {
  try {
    const edits = await StorageService.getRecentPriorityEdits(projectName, limit);
    return { success: true, data: edits };
  } catch (error) {
    console.error('Get recent priority edits error:', error);
    return { success: false, error: error.message };
  }
});

// Get priority edit statistics
ipcMain.handle('get-priority-edit-stats', async (_, projectName: string) => {
  try {
    const stats = await StorageService.getPriorityEditStats(projectName);
    return { success: true, data: stats };
  } catch (error) {
    console.error('Get priority edit stats error:', error);
    return { success: false, error: error.message };
  }
});

// Open external URL in default browser
ipcMain.handle('open-external', async (_, url: string) => {
  try {
    await shell.openExternal(url);
  } catch (error) {
    console.error('Failed to open external URL:', error);
  }
});

/**
 * Migrate existing projects to include type field
 * Defaults all projects without a type to 'code'
 */
async function migrateProjectsToIncludeType() {
  try {
    const projects = await StorageService.getProjects();
    let needsMigration = false;

    const migratedProjects = projects.map(project => {
      if (!project.type) {
        needsMigration = true;
        console.log(`Migrating project "${project.name}" to type: code`);
        return {
          ...project,
          type: 'code' as const
        };
      }
      return project;
    });

    if (needsMigration) {
      // Save migrated projects
      const projectsPath = path.join(os.homedir(), '.project-stickies', 'projects.json');
      const { promises: fsPromises } = require('fs');
      await fsPromises.writeFile(projectsPath, JSON.stringify(migratedProjects, null, 2), 'utf-8');
      console.log('Successfully migrated projects to include type field');
    } else {
      console.log('No project migration needed - all projects have type field');
    }
  } catch (error) {
    console.error('Migration failed:', error);
    // Don't throw - we want the app to continue even if migration fails
  }
}

// Initialize storage on app ready
app.whenReady().then(async () => {
  await StorageService.initialize();
  await migrateProjectsToIncludeType();
});
