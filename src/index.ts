import { app, BrowserWindow, ipcMain } from 'electron';
import { StorageService } from './services/storage';
import { ContextService } from './services/context';
import { ClaudeService } from './services/claude';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Initialize services
let claudeService: ClaudeService | null = null;

// File watcher management
const fileWatchers = new Map<BrowserWindow, { watcher: fs.FSWatcher; timeout: NodeJS.Timeout | null; projectName: string }>();

/**
 * Start watching a project's notes.json file for external changes
 */
function startWatchingProject(window: BrowserWindow, projectName: string) {
  // Stop any existing watcher for this window
  stopWatchingProject(window);

  const notesPath = path.join(os.homedir(), '.project-stickies', projectName, 'notes.json');

  try {
    const watcher = fs.watch(notesPath, (eventType) => {
      if (eventType === 'change') {
        // Get watcher data
        const watcherData = fileWatchers.get(window);
        if (!watcherData) return;

        // Debounce: Clear existing timeout
        if (watcherData.timeout) {
          clearTimeout(watcherData.timeout);
        }

        // Set new timeout (300ms debounce)
        watcherData.timeout = setTimeout(() => {
          // Send event to renderer
          window.webContents.send('notes-file-changed', projectName);
          watcherData.timeout = null;
        }, 300);
      }
    });

    fileWatchers.set(window, { watcher, timeout: null, projectName });
    console.log(`Started watching notes.json for project: ${projectName}`);
  } catch (error) {
    console.error(`Failed to watch notes.json for ${projectName}:`, error);
  }
}

/**
 * Stop watching files for a window
 */
function stopWatchingProject(window: BrowserWindow) {
  const watcherData = fileWatchers.get(window);
  if (watcherData) {
    watcherData.watcher.close();
    if (watcherData.timeout) {
      clearTimeout(watcherData.timeout);
    }
    fileWatchers.delete(window);
    console.log(`Stopped watching notes.json for project: ${watcherData.projectName}`);
  }
}

/**
 * Create a new window, optionally for a specific project
 * @param projectName - Optional project to open in the window
 */
const createWindow = (projectName?: string): void => {
  // Create the browser window according to PRD specs
  const mainWindow = new BrowserWindow({
    width: 600,
    height: 800,
    minWidth: 400,
    minHeight: 500,
    frame: false, // Frameless window for sticky note look
    transparent: true, // Enable transparency for rounded corners
    hasShadow: true, // Drop shadow for sticky note effect
    backgroundColor: '#1a1a1a',
    resizable: true,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  // Build URL with optional project parameter
  let url = MAIN_WINDOW_WEBPACK_ENTRY;
  if (projectName) {
    // Pass project as query parameter
    url += `?project=${encodeURIComponent(projectName)}`;
    // Set window title to project name
    mainWindow.setTitle(`Oscribble - ${projectName}`);
  } else {
    mainWindow.setTitle('Oscribble');
  }

  // Load the app with optional project context
  mainWindow.loadURL(url);

  // Open the DevTools in development
  if (process.env.NODE_ENV === 'development') {
    mainWindow.webContents.openDevTools();
  }

  // Cleanup watcher when window closes
  mainWindow.on('closed', () => {
    stopWatchingProject(mainWindow);
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => createWindow());

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

// IPC Handlers - Register these BEFORE app ready to ensure they're available immediately

// Initialize Claude service
ipcMain.handle('init-claude', async (_, apiKey: string) => {
  try {
    claudeService = new ClaudeService(apiKey);
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Get app settings
ipcMain.handle('get-settings', async () => {
  try {
    return await StorageService.getSettings();
  } catch (error) {
    return null;
  }
});

// Save app settings
ipcMain.handle('save-settings', async (_, settings) => {
  try {
    await StorageService.saveSettings(settings);
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Get all projects
ipcMain.handle('get-projects', async () => {
  try {
    return await StorageService.getProjects();
  } catch (error) {
    return [];
  }
});

// Add new project
ipcMain.handle('add-project', async (_, project) => {
  try {
    await StorageService.addProject(project);
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Update existing project
ipcMain.handle('update-project', async (_, project) => {
  try {
    await StorageService.updateProject(project);
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Delete project
ipcMain.handle('delete-project', async (_, projectName: string) => {
  try {
    await StorageService.deleteProject(projectName);
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Get notes for project
ipcMain.handle('get-notes', async (_, projectName: string) => {
  try {
    return await StorageService.getNotes(projectName);
  } catch (error) {
    return null;
  }
});

// Save notes
ipcMain.handle('save-notes', async (_, projectName: string, notes) => {
  try {
    await StorageService.saveNotes(projectName, notes);
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Save raw text (autosave)
ipcMain.handle('save-raw', async (_, projectName: string, text: string) => {
  try {
    await StorageService.saveRawText(projectName, text);
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Get raw text
ipcMain.handle('get-raw', async (_, projectName: string) => {
  try {
    return await StorageService.getRawText(projectName);
  } catch (error) {
    return null;
  }
});

// Gather context from mentions
ipcMain.handle('gather-context', async (_, rawText: string, projectRoot: string) => {
  try {
    const context = await ContextService.gatherContext(rawText, projectRoot);
    const formatted = ContextService.formatContextForPrompt(context);
    return { success: true, context: formatted };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Format with Claude
ipcMain.handle('format-with-claude', async (_, rawText: string, contextStr: string) => {
  try {
    if (!claudeService) {
      throw new Error('Claude service not initialized');
    }
    const response = await claudeService.formatTasks(rawText, contextStr);
    return { success: true, data: response };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Get project files for autocomplete
ipcMain.handle('get-project-files', async (_, projectRoot: string) => {
  try {
    const { promises: fs } = require('fs');
    const path = require('path');

    const files: string[] = [];
    const maxFiles = 500; // Limit for performance

    async function scanDirectory(dir: string, relativePath: string = '') {
      if (files.length >= maxFiles) return;

      try {
        const entries = await fs.readdir(dir, { withFileTypes: true });

        for (const entry of entries) {
          if (files.length >= maxFiles) break;

          // Skip common ignore patterns
          if (
            entry.name.startsWith('.') ||
            entry.name === 'node_modules' ||
            entry.name === 'dist' ||
            entry.name === 'build' ||
            entry.name === '.webpack'
          ) {
            continue;
          }

          const fullPath = path.join(dir, entry.name);
          const relPath = relativePath ? `${relativePath}/${entry.name}` : entry.name;

          if (entry.isDirectory()) {
            await scanDirectory(fullPath, relPath);
          } else if (entry.isFile()) {
            files.push(relPath);
          }
        }
      } catch (error) {
        // Skip directories we can't read
      }
    }

    await scanDirectory(projectRoot);
    return { success: true, files };
  } catch (error) {
    return { success: false, error: error.message, files: [] };
  }
});

// Get directory suggestions for path autocomplete
ipcMain.handle('get-directory-suggestions', async (_, partialPath: string) => {
  try {
    const { promises: fs } = require('fs');
    const path = require('path');
    const os = require('os');

    let searchPath = partialPath || os.homedir();
    let searchDir = '';
    let prefix = '';

    // Expand ~ to home directory
    if (searchPath.startsWith('~')) {
      searchPath = searchPath.replace('~', os.homedir());
    }

    // Determine which directory to search and what prefix to match
    try {
      const stats = await fs.stat(searchPath);
      if (stats.isDirectory()) {
        // If it's a valid directory and ends with /, show its contents
        if (searchPath.endsWith('/') || searchPath.endsWith(path.sep)) {
          searchDir = searchPath;
          prefix = '';
        } else {
          // Valid directory but no trailing slash - show siblings
          searchDir = path.dirname(searchPath);
          prefix = path.basename(searchPath).toLowerCase();
        }
      }
    } catch {
      // Path doesn't exist yet, search parent directory
      searchDir = path.dirname(searchPath);
      prefix = path.basename(searchPath).toLowerCase();
    }

    // Read directory
    const entries = await fs.readdir(searchDir, { withFileTypes: true });
    const directories: string[] = [];

    for (const entry of entries) {
      if (entry.isDirectory()) {
        const name = entry.name;
        // Skip hidden directories
        if (name.startsWith('.')) {
          continue;
        }

        // Filter by prefix if provided
        if (prefix && !name.toLowerCase().startsWith(prefix)) {
          continue;
        }

        const fullPath = path.join(searchDir, name);
        directories.push(fullPath);

        if (directories.length >= 5) break; // Limit to 5
      }
    }

    return { success: true, directories };
  } catch (error) {
    console.error('Directory suggestions error:', error);
    return { success: false, error: error.message, directories: [] };
  }
});

// Open a new window for a specific project
ipcMain.handle('open-project-window', async (_, projectName: string) => {
  try {
    // Verify project exists
    const projects = await StorageService.getProjects();
    const project = projects.find(p => p.name === projectName);

    if (!project) {
      return { success: false, error: 'Project not found' };
    }

    // Create new window with project context
    createWindow(projectName);

    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Close the current window
ipcMain.handle('close-window', async (event) => {
  const window = BrowserWindow.fromWebContents(event.sender);
  if (window) {
    window.close();
  }
  return { success: true };
});

// Start watching a project's notes.json file
ipcMain.handle('start-watching-project', async (event, projectName: string) => {
  const window = BrowserWindow.fromWebContents(event.sender);
  if (window) {
    startWatchingProject(window, projectName);
  }
  return { success: true };
});

// Stop watching the current project
ipcMain.handle('stop-watching-project', async (event) => {
  const window = BrowserWindow.fromWebContents(event.sender);
  if (window) {
    stopWatchingProject(window);
  }
  return { success: true };
});

// Initialize storage on app ready
app.whenReady().then(async () => {
  await StorageService.initialize();
});
